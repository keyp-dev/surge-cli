# Internationalization (i18n) Guidelines

surge-tui uses **compile-time language selection** with zero runtime overhead.

## Core Principles

### 1. Compile-time Selection, Not Runtime

**Use Cargo features to control language:**
```toml
[features]
default = ["lang-zh-cn"]
lang-zh-cn = []
lang-en-us = []
```

**Build different language versions:**
```bash
# Chinese version (default)
cargo build --release

# English version
cargo build --release --no-default-features --features lang-en-us
```

**Don't use:** Runtime config files, environment variables, command-line parameters for language selection.

**Why?** Zero runtime overhead. All strings are `&'static str`, directly inlined into the binary.

### 2. Trait-based, Type-safe

**All translations through `Translate` trait:**
```rust
pub trait Translate: Send + Sync {
    fn ui_status_running(&self) -> &'static str;
    fn notification_test_completed(&self, alive: usize, total: usize) -> String;
    // ...
}
```

**Each language implements this trait:**
```rust
pub struct ZhCN;
impl Translate for ZhCN {
    fn ui_status_running(&self) -> &'static str {
        "Surge 运行中"
    }
    // ...
}
```

**Compiler guarantees completeness:** When adding new translation keys, all language files must implement them, otherwise compilation fails.

### 3. No Translation in Domain and Infrastructure

**Only UI layer uses translations.**

Domain and infrastructure return raw values (enums, numbers, booleans), not text.

**Bad example:**
```rust
// ❌ In domain
pub enum OutboundMode {
    Direct,
}
impl OutboundMode {
    fn as_str(&self) -> &str {
        "直连模式"  // Hardcoded Chinese
    }
}
```

**Correct approach:**
```rust
// ✅ domain only defines enum
pub enum OutboundMode {
    Direct,
}

// ✅ UI layer translates
let text = match mode {
    OutboundMode::Direct => t.outbound_mode_direct(),
    // ...
};
```

**Why?** Domain is business core, should not depend on language. Translation is a presentation layer concern.

## Adding New Translations

### Static Text (Recommended)

**Use case:** UI labels, button text, fixed messages.

**1. Add method in `i18n/mod.rs`:**
```rust
pub trait Translate {
    fn new_feature_label(&self) -> &'static str;
}
```

**2. Implement in each language file:**
```rust
// zh_cn.rs
fn new_feature_label(&self) -> &'static str {
    "新功能"
}

// en_us.rs
fn new_feature_label(&self) -> &'static str {
    "New Feature"
}
```

**3. Use in UI:**
```rust
let t = i18n::current();
let label = t.new_feature_label();
```

### Dynamic Text (With Parameters)

**Use case:** Messages containing variables (quantity, time, name).

**1. Define parameterized method in trait:**
```rust
pub trait Translate {
    fn test_result(&self, alive: usize, total: usize) -> String;
}
```

**2. Implement formatting in language files:**
```rust
// zh_cn.rs
fn test_result(&self, alive: usize, total: usize) -> String {
    format!("测试完成: {}/{} 可用", alive, total)
}

// en_us.rs
fn test_result(&self, alive: usize, total: usize) -> String {
    format!("Test completed: {}/{} available", alive, total)
}
```

**3. Use in UI:**
```rust
let message = t.test_result(42, 100);
```

**Note:** Returns `String` not `&'static str`, because it's dynamically generated.

## Grouping Convention

**Group by function, not by language:**
```rust
pub trait Translate {
    // ========== UI Status Bar ==========
    fn ui_status_running(&self) -> &'static str;
    fn ui_status_stopped(&self) -> &'static str;

    // ========== Policy Group ==========
    fn policy_group_title(&self) -> &'static str;
    fn policy_testing(&self) -> &'static str;
}
```

**Why?** Easy to find related translations, maintains functional cohesion.

## Adding New Language

**Steps:**

**1. Add feature in Cargo.toml:**
```toml
[features]
lang-ja-jp = []
```

**2. Create `i18n/ja_jp.rs`:**
```rust
use super::Translate;

pub struct JaJP;

impl Translate for JaJP {
    // Implement all methods
}
```

**3. Register in `i18n/mod.rs`:**
```rust
mod ja_jp;
pub use ja_jp::JaJP;

#[cfg(feature = "lang-ja-jp")]
pub type CurrentLang = JaJP;

#[cfg(feature = "lang-ja-jp")]
pub fn current() -> &'static dyn Translate {
    static INSTANCE: JaJP = JaJP;
    &INSTANCE
}
```

**4. Update README.md documentation.**

## Getting Translation Instance

**In UI components:**
```rust
use crate::i18n;

// In functions
let t = i18n::current();
let text = t.ui_status_running();
```

**Don't:**
- ❌ Cache `i18n::current()` in struct field
- ❌ Store translation instance at App initialization

**Why?** `current()` returns `&'static`, calling it has zero cost. Keep it simple.

## Shortcut Key Special Handling

**Keep shortcut key text concise:**
```rust
fn key_quit(&self) -> &'static str {
    "[q]uit"  // Concise, suitable for status bar
}
```

**Descriptive text in component hints:**
```rust
fn policy_group_enter_hint(&self) -> &'static str {
    "策略组 [Enter进入]"  // Full description
}
```

**Why?** Status bar has limited space, separation of concerns.

## Testing Translations

**Verify all languages compile:**
```bash
# Test Chinese
cargo check --features lang-zh-cn

# Test English
cargo check --no-default-features --features lang-en-us

# Test all languages
cargo check --all-features
```

**Common errors:**
- Forgot to implement new method → compilation fails (good thing)
- Return type mismatch → compilation fails
- Hardcoded text in UI → manual review

## Naming Convention

**Prefix indicates location:**
- `ui_*` - UI global (status bar, title)
- `key_*` - Shortcut keys
- `view_*` - View titles
- `notification_*` - Notification messages
- `alert_*` - Alert messages
- `policy_*` - Policy related
- `request_*` - Request related
- `stats_*` - Statistics labels

**Concise and clear:**
- ✅ `policy_testing` - good
- ❌ `policy_group_list_item_testing_indicator` - too verbose

## Anti-patterns

**Don't:**
- ❌ Hardcode translations in domain/infrastructure
- ❌ Use runtime config files for language selection
- ❌ Cache translation instances (unnecessary)
- ❌ Mix multiple languages in one language file
- ❌ Use HashMap to store translations (compile-time is enough)

## Performance

**Zero-overhead abstraction:**
- `&'static str` directly inlined into binary
- No runtime lookup, no hash tables
- Trait method calls are inlined after release optimization
- Feature flags decided at compile-time, no `if cfg!()` overhead

**Measured:** Compared to hardcoded strings, performance difference < 1% (identical after optimization).

---

*"Make the change easy, then make the easy change."*
